##### 자바스크립트의 데이터 타입
* 기본타입
>1. 숫자(Number)
>2. 문자열(String)
>3. 불린값(Boolean)
>4. undefined
>5. null

* 참조 타입
>* 객체
>>1.배열  
>>2.함수  
>>3.정규표현식

#### 자바스크립트 기본 타입
5가지 타입 모두 그 자체가 하나의 값을 나타낸다.    
자바스크립트는 **느슨한 타입 체크 언어**이다.  
엄격한 타입 체크 언어는 변수를 선헌할 때 변수에 저장할 데이터 정류(문자, 정수 ,실수 등)에 따리 자료형 예약어를 이용하여 변수의 데이터타입을 지정해야 한다.  
자바스크립트는 변수를 선언할 때 타입을 정하지 않고 var라는 한 가지 키워드로만 변수를 선언한다.  
변수에 어떤 데이터라도 저장하는 것이 가능.

#### 숫자
c언어 경우 정수, 실수에 따라 다양한 숫자 타입이 존제, 자바스크립트 **하나의 숫자형**만 존재
자바스크립트에서는 모든 숫자를 64비트 부도 소수점 형태로 저장.(예 : double)  
JS에서는 모든 숫자를 실수로 처리 나눗셈 연산시 주의

#### 문자열
문자열은 작은 따옴표(') 또는 큰따옴표(")로 생성  
한번 정의된 문자열은 변하지 않는다.  
문자열은 배열처럼 인덱스를 이용해서 접근할 수 있다.  
자바스크립트에서는 한 번 생성된 문자열은 읽기만 가능 수정 불가능.

#### 불린값
java와 같이 true, false를 나타낸다.

#### null과 undefined
모두 값이 비어있음을 나타낸다.
 
undefined : 기본적으로 값이 할당되지 않는 변수
>타입이자, 감을 나타낸다.

null : 개발자가 명시적으로 값이 비어있음을 나타내는 데 사용한다.
js에서 null 타입 변수인지 확인할 때 typeof연산자를 사용하면 안 되고, 일치 연산자(===)를 사용해서 변수의 값을 직접 확인해야한다.

```
// null 타입 변수 생성.
var nullVar = nulL
console.1og(typeof nullVar === dnull) // 출력값 false
Console.1og(nullVar === null)’ //  출력값 true
```

#### 자바스크립트 참조 타입(객체 타입)
기본타입을 제외한 모든 값은 객체. 배열, 함수, 정규표현식 모두 js의 객체로 표현  
js에서는 객체는 단순 이름(key):값(value) 형태의 프로퍼티들을 저장하는 컨테이너로서, 컴퓨터 과학 분야에서 hash라는 자료구조와 비슷하다.  
js의 기본 타입은 하나의 값만 가지는 데 비해. 참조 타입인 객체는 여러 개의 프로퍼티들을 포함 할 수 있다.  
객체 프로퍼티는 기본 타입의 값을 포함 또는 다른 객체를 가리킬 수도 있다.  
프로퍼티의 성질에 따라 객체의 프로퍼티는 함수로 포함할 수 있다 이를 js에서 프로퍼티를 메서드라고 부른다.  

#### 객체 생성
객체 생성시 java는 class를 정의 class의 instance를 생성하는 과정에 객체가 생성  
js는 class라는 개념이 없고, 객체 리터럴이나 생성자 함수등 별도 방식이 존재  

##### Object()생성자 함수 이용
```
var foo = new Object(); // undefined

foo.a = 'a'; //일급 객체 특징
```

##### 객체 리터럴 방식 이용
객체를 생성하는 표기법을 의미한다.
리터럴: 용어의 의미를 표기법.

객체 리터럴은 중괄호 {}를 이용해서 객체를 생성하다.
var foo = {}; //빈객체 생성
중괄호 안에 "key" : "value"의 형태로 표기하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다.  
key는 문자열, 숫자가 가능하고 프로퍼티값은 어떤 표현식이든 올 수 있다. 함수도 가능하다(이 경우 프로퍼티 메서드라 칭한다). 

##### 생성자 함수 이용
4장에서 추가 기입함

#### 객체 프로퍼티 읽기/쓰기/갱신
객체는 새로운 값을 가진 프로퍼티를 생성, 접근하여 해당 값을 읽거나 원하는 값으로 프로퍼티의 값을 갱신할 수 있다.

* 대괄호 ([])표기법
* 마침표 (.) 표기법

```
var member = {
    name = 'jun',
    status = 'vip'
};
```

#### 프로퍼티 읽기
```
console.log(member.name); // jun
```
마침표 표기법
-> 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다.
대괄호 표기법
-> 객체의 프로퍼티를 문자열 형태로 만든 다음 대괄호를 둘러 싸면 된다. **대괄호 안의 프로퍼티 이름을 문자열 형태로**해야한다.  
> * JS 대괄호표기법에서 접근하려는 프로퍼티 이름을 문자열로 하지 않으면 toString()을 자동 호출해서 문자열로 바꾸는 시도를하고 객체에 없는 프로퍼티에 접근하는 경우 undefined를 출력한다.


#### 프로퍼티 갱신
```
member.name = 'hojun';
```
프로퍼티에 접근해서 객체의 기존 프로퍼티값을 갱신할 수 있다. 마침표 표기법, 대괄호 표기법 둘다 사용이 가능하다.

#### 프로퍼티 동적 생성
```
member.sex = men;
```
JS에서는 객체가 생성된 후 동적으로 프로퍼티를 생성해서, 해당 객체에 추가할 수 있다.  
**자바스크립트 객체의 프로퍼티 값을 할당할 때, 프로퍼티가 이미 있을 경우 해당 프로퍼티의 값이 갱신되지만 객체의 해당 프로퍼티가 없을 경우에는 새로운 프로퍼티가 동적으로 생성된 후 값이 할당된다.**

#### 대괄호 대괄호 표기법만을 사용해야 할 경우
```
member['full-name'] = 'choi hojun';
console.log(member['full-name']); // 정상
console.log(member.full-name');   // Nan
console.log(member.full); // undefined
```
접근하려는 프로퍼티가 표현식이거나 예약어일 경우 대괄호 표기법으로 접근해야한다. full-name은 연산자 '-'가 있는 표현식이다.
member.full 존재하지 않는 프로퍼티를 접근하였기 때문에 undefined로 출력 된다.

##### NaN(Not a Number)값
js에서 수치 연산을 해서 정상적인 값을 얻지 못할 때 출력 

#### for in 문과 객체 프로퍼티 출력
```
객체 리터럴을 통한 member 객체 생성
var member = {
    name = 'jun',
    status = 'vip',
    age = '34'
};

// for in 문을 이용한 ?체 프로퍼티 출력

var prop;
for (prop in member) {
    console.log(prop, member[prop]);
}

```

for in 문을 사용하면 foreach문과 같은 효과를 낸다. prop변수에  member 객체의 프로퍼티가 하나씩 할당된다.  
대괄호 표기법으로 member[prop]와 같이 이용하여 프로퍼티값을 출력한 것.
java에서는 prop의 자료형이 중요하였지만 js에서는 상관 없다.

#### 객체 프로퍼티 삭제
JS에서 객체 프로퍼티를 delete연산자를 이용해 즉시 삭제할 수 있다.
**delete 연산자는 객체의 프로퍼티를 삭제할 분 객체를 삭제하지는 못한다.**

```
var member = {
    name = 'jun',
    status = 'vip',
    age = '34'
};
delete member.age; 
console.log(member.age); //undefined

```

delete 연산자로 프로퍼티를 삭제 하였고 존재하지 않는 프로퍼티에 접근할 경우 undefined로 출력

#### 참조 타입의 특성
JS에서 기본 타입 숫자, 문자, 불린값, null, undifined, simbol등 이를 제외한 모든 값은 객체.  
배열, 함수, 객체로 취급 이를 참조 타입으로 부른다. 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다.  
```
var objA = {
    val : 40
}
var objB = objA;

console.log(obJA.val); // 40
console.log(objB.val); // 40

objB.val = 50;

console.log(objA.val); // 50
console.log(objB.val); // 50
```

objA 객체는 리터럴 방식으로 생성. 객체 자체를 저장하는 것이 아닌 생성된 객체를 가리키는 참조값을 저장하고 있다는 것을 기억하자.  
변수 objB에 objA의 값을 할당한다. objA는 생성된 객체를 가리키는 참조값을 가지고 있다 변수가 objB에도 같은 객체? 참조값을 저장한다.  
동일한 객체를 가리키는 참조값을 가지게 된다.  

**실제로 객체를 참조하는 값을 저장할 뿐 실제 객체를 나타내지는 않는다. objA 객체는 참조 변수 objA가 가리키고 있는 객체를 나타낸다.**

