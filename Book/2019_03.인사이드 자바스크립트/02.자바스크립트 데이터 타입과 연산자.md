##### 자바스크립트의 데이터 타입
* 기본타입
>1. 숫자(Number)
>2. 문자열(String)
>3. 불린값(Boolean)
>4. undefined
>5. null

* 참조 타입
>* 객체
>>1.배열  
>>2.함수  
>>3.정규표현식

#### 자바스크립트 기본 타입
5가지 타입 모두 그 자체가 하나의 값을 나타낸다.    
자바스크립트는 **느슨한 타입 체크 언어**이다.  
엄격한 타입 체크 언어는 변수를 선헌할 때 변수에 저장할 데이터 정류(문자, 정수 ,실수 등)에 따리 자료형 예약어를 이용하여 변수의 데이터타입을 지정해야 한다.  
자바스크립트는 변수를 선언할 때 타입을 정하지 않고 var라는 한 가지 키워드로만 변수를 선언한다.  
변수에 어떤 데이터라도 저장하는 것이 가능.

#### 숫자
c언어 경우 정수, 실수에 따라 다양한 숫자 타입이 존제, 자바스크립트 **하나의 숫자형**만 존재
자바스크립트에서는 모든 숫자를 64비트 부도 소수점 형태로 저장.(예 : double)  
JS에서는 모든 숫자를 실수로 처리 나눗셈 연산시 주의

#### 문자열
문자열은 작은 따옴표(') 또는 큰따옴표(")로 생성  
한번 정의된 문자열은 변하지 않는다.  
문자열은 배열처럼 인덱스를 이용해서 접근할 수 있다.  
자바스크립트에서는 한 번 생성된 문자열은 읽기만 가능 수정 불가능.

#### 불린값
java와 같이 true, false를 나타낸다.

#### null과 undefined
모두 값이 비어있음을 나타낸다.
 
undefined : 기본적으로 값이 할당되지 않는 변수
>타입이자, 감을 나타낸다.

null : 개발자가 명시적으로 값이 비어있음을 나타내는 데 사용한다.
js에서 null 타입 변수인지 확인할 때 typeof연산자를 사용하면 안 되고, 일치 연산자(===)를 사용해서 변수의 값을 직접 확인해야한다.

```
// null 타입 변수 생성.
var nullVar = nulL
console.1og(typeof nullVar === dnull) // 출력값 false
Console.1og(nullVar === null)’ //  출력값 true
```

#### 자바스크립트 참조 타입(객체 타입)
기본타입을 제외한 모든 값은 객체. 배열, 함수, 정규표현식 모두 js의 객체로 표현  
js에서는 객체는 단순 이름(key):값(value) 형태의 프로퍼티들을 저장하는 컨테이너로서, 컴퓨터 과학 분야에서 hash라는 자료구조와 비슷하다.  
js의 기본 타입은 하나의 값만 가지는 데 비해. 참조 타입인 객체는 여러 개의 프로퍼티들을 포함 할 수 있다.  
객체 프로퍼티는 기본 타입의 값을 포함 또는 다른 객체를 가리킬 수도 있다.  
프로퍼티의 성질에 따라 객체의 프로퍼티는 함수로 포함할 수 있다 이를 js에서 프로퍼티를 메서드라고 부른다.  

#### 객체 생성
객체 생성시 java는 class를 정의 class의 instance를 생성하는 과정에 객체가 생성  
js는 class라는 개념이 없고, 객체 리터럴이나 생성자 함수등 별도 방식이 존재  

##### Object()생성자 함수 이용
```
var foo = new Object(); // undefined

foo.a = 'a'; //일급 객체 특징
```

##### 객체 리터럴 방식 이용
객체를 생성하는 표기법을 의미한다.
리터럴: 용어의 의미를 표기법.

객체 리터럴은 중괄호 {}를 이용해서 객체를 생성하다.
var foo = {}; //빈객체 생성
중괄호 안에 "key" : "value"의 형태로 표기하면 해당 프로퍼티가 추가된 객체를 생성할 수 있다.  
key는 문자열, 숫자가 가능하고 프로퍼티값은 어떤 표현식이든 올 수 있다. 함수도 가능하다(이 경우 프로퍼티 메서드라 칭한다). 

##### 생성자 함수 이용
4장에서 추가 기입함

#### 객체 프로퍼티 읽기/쓰기/갱신
객체는 새로운 값을 가진 프로퍼티를 생성, 접근하여 해당 값을 읽거나 원하는 값으로 프로퍼티의 값을 갱신할 수 있다.

* 대괄호 ([])표기법
* 마침표 (.) 표기법

```
var member = {
    name = 'jun',
    status = 'vip'
};
```

#### 프로퍼티 읽기
```
console.log(member.name); // jun
```
마침표 표기법
-> 객체 다음에 마침표를 찍고 원하는 속성값을 적으면 된다.
대괄호 표기법
-> 객체의 프로퍼티를 문자열 형태로 만든 다음 대괄호를 둘러 싸면 된다. **대괄호 안의 프로퍼티 이름을 문자열 형태로**해야한다.  
> * JS 대괄호표기법에서 접근하려는 프로퍼티 이름을 문자열로 하지 않으면 toString()을 자동 호출해서 문자열로 바꾸는 시도를하고 객체에 없는 프로퍼티에 접근하는 경우 undefined를 출력한다.


#### 프로퍼티 갱신
```
member.name = 'hojun';
```
프로퍼티에 접근해서 객체의 기존 프로퍼티값을 갱신할 수 있다. 마침표 표기법, 대괄호 표기법 둘다 사용이 가능하다.

#### 프로퍼티 동적 생성
```
member.sex = men;
```
JS에서는 객체가 생성된 후 동적으로 프로퍼티를 생성해서, 해당 객체에 추가할 수 있다.  
**자바스크립트 객체의 프로퍼티 값을 할당할 때, 프로퍼티가 이미 있을 경우 해당 프로퍼티의 값이 갱신되지만 객체의 해당 프로퍼티가 없을 경우에는 새로운 프로퍼티가 동적으로 생성된 후 값이 할당된다.**

#### 대괄호 대괄호 표기법만을 사용해야 할 경우
```
member['full-name'] = 'choi hojun';
console.log(member['full-name']); // 정상
console.log(member.full-name');   // Nan
console.log(member.full); // undefined
```
접근하려는 프로퍼티가 표현식이거나 예약어일 경우 대괄호 표기법으로 접근해야한다. full-name은 연산자 '-'가 있는 표현식이다.
member.full 존재하지 않는 프로퍼티를 접근하였기 때문에 undefined로 출력 된다.

##### NaN(Not a Number)값
js에서 수치 연산을 해서 정상적인 값을 얻지 못할 때 출력 

#### for in 문과 객체 프로퍼티 출력
```
객체 리터럴을 통한 member 객체 생성
var member = {
    name = 'jun',
    status = 'vip',
    age = '34'
};

// for in 문을 이용한 ?체 프로퍼티 출력

var prop;
for (prop in member) {
    console.log(prop, member[prop]);
}

```

for in 문을 사용하면 foreach문과 같은 효과를 낸다. prop변수에  member 객체의 프로퍼티가 하나씩 할당된다.  
대괄호 표기법으로 member[prop]와 같이 이용하여 프로퍼티값을 출력한 것.
java에서는 prop의 자료형이 중요하였지만 js에서는 상관 없다.

#### 객체 프로퍼티 삭제
JS에서 객체 프로퍼티를 delete연산자를 이용해 즉시 삭제할 수 있다.
**delete 연산자는 객체의 프로퍼티를 삭제할 분 객체를 삭제하지는 못한다.**

```
var member = {
    name = 'jun',
    status = 'vip',
    age = '34'
};
delete member.age; 
console.log(member.age); //undefined

```

delete 연산자로 프로퍼티를 삭제 하였고 존재하지 않는 프로퍼티에 접근할 경우 undefined로 출력

#### 참조 타입의 특성
JS에서 기본 타입 숫자, 문자, 불린값, null, undifined, simbol등 이를 제외한 모든 값은 객체.  
배열, 함수, 객체로 취급 이를 참조 타입으로 부른다. 객체의 모든 연산이 실제 값이 아닌 참조값으로 처리되기 때문이다.  
```
var objA = {
    val : 40
}
var objB = objA;

console.log(obJA.val); // 40
console.log(objB.val); // 40

objB.val = 50;

console.log(objA.val); // 50
console.log(objB.val); // 50
```

objA 객체는 리터럴 방식으로 생성. 객체 자체를 저장하는 것이 아닌 생성된 객체를 가리키는 참조값을 저장하고 있다는 것을 기억하자.  
변수 objB에 objA의 값을 할당한다. objA는 생성된 객체를 가리키는 참조값을 가지고 있다 변수가 objB에도 같은 객체? 참조값을 저장한다.  
동일한 객체를 가리키는 참조값을 가지게 된다.  

**실제로 객체를 참조하는 값을 저장할 뿐 실제 객체를 나타내지는 않는다. objA 객체는 참조 변수 objA가 가리키고 있는 객체를 나타낸다.**

#### 객체 비교
동등 연산자(==)를 사용하여 두 객체를 비교할 대도 객체의 프로퍼티값이 아닌 참조값을 비교한다.

```
var a = 100;
var b = 100;

var objA = {value : 100};
var objB = {value : 100};
var objC = objB;

a == b // true
기본 타입 변수 값 비교
objA == objB // false
객체 참조 타입 참조값이 같아야 true equal메소드로 비교시 값 비교
objB == objC // true
같은 객체 참조
```

#### 참조에 의한 함수 호출 방식
**기본 타입의 경우 Call By Value.**  
함수를 호출할 때 인자로 기본 타입의 값을 넘길 경우. 호출된 함수의 매개변수로 복사된 값이 전달.  
함수 내부에서 매개변수를 이용 값 변경해도 실제로 호출된 변수의 값이 변경되지 않는다.  

**참조 타입 Call By Reference.**  
함수를 호출할 때 인자로 참조 타입인 객체를 전달할 경우. 객체의 프로퍼티값이 함수의 매개변수로 복사 되지 않고 그대로 내부 로 전달.

#### 프로토타입
**JS의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다.**  
상속 개념과 같이 부모 객체의 프로퍼티를 마치 자신의 것처럼 쓸 수 있다.  

```
var member = {
    name = 'hojun',
    age = '34'
};

console.log(member.toString());
console.dir(member);
```
toString()을 정의하지 않아도 프로토타입에 toString()이 이미 정의되어 있어 상송처럼 호출했다.   
크롬 브라우져에서 console.dif(객체명); 을 출력 할 경우 proto 프로퍼티가 있다.  
모든 객체는 자신을 트로포타입을 가리키는[[Prototype]]라는 숨겨진 프로퍼티가 있다. 크롬에선 -Proto-로 구현돼 있다.

**리터럴 방식으로 생성된 객체의 경우 Object.prototype 객체**가 프로토타입 객체가 된다.  
객체를 생성할 때 임의 다른 객체로 프로토타입을 변경하는 것도 가능하다.

#### 배열
기존 배열과 같은 기능을 한다. 어떤 위치에 어떤 타입의 데이터를 저장하더라도 에러가 발생하지 않는다.  

##### 배열 리터럴
Js에서 새로운 배열을 만드는 데 사용한다.  
객체 리터럴 {} == 중괄호, 배열 리터럴 [] == 대괄호를 사용한다. 
```
var codeArr = ['a','b','c'];
console.log(codeArr[0]);
```
배열 티러털에서는 각 요소의 값만 포함한다. 대괄호 내에 접근하고자 하는 원소에 배열 내 위치 인덱스값을 넣어 접근한다.

##### 배열의 요소 생성
JS의 배열은 값을 순차적으로 넣을 필요 없이 아무 인덱스 위쳉나 값을 동적으로 추가할 수 있다.  
```
var arr = [];
arr[0] = '1'; 
arr[3] = '2';
arr[7] = '3';

arr -> print [1,undefined, undefined, 2, undefined,undefined,undefined, 3]
arr.length -> print 8;
```

요소가 없는 빈 배열 생성. index를 아무값으로 넣어서 추가 할 수 있다.

**length 프로퍼티**
배열 메서드는 length 프로퍼티를 기반으로 동작한다. 동적 할당, push등 배열에 추가 추가될 때 배열의 length 프로퍼티는 현 배열에 마지막 원소의 index +1 를 의미한다.  
length 프로퍼티가 가리키는 인덱스를 기반으로 배열의 참조주소가 없어지거나 undefined 선언으로 체워지거나 둘중 하나로 동작한다.

####배열과 객체
배열에는 length 프로퍼티가 존재함. push()와 같은 표준 배열 메서드를 사용할 수 없다.  
Array.prototype 객체가 부모객체로 프로토타입이 된다.

리터럴 방식 객체는 Object.prototype 객체가 부모객체로 프로토타입이 된다.  

객체는 자신의 프로토타입이 가지는 모든 프로퍼티 및 메서드들을 상속받아 사용할 수 있다.

####배열의 프로퍼티 동적 생성
배열도 JS객체. 인덱스가 숫자인 배열 원소 이외 객체처럼 동적 프로퍼티 추가할 수 있다.  
```
var arr = ['zero','one','two'];
arr.length // 3

// 배열 원소 추가
arr.type = 'int';
arr.code = 'num';

arr.length // 3

동적프로퍼티가 추가될 경우 배열의 length 은 변하지 않고 배열 원소를 추가하였을 때 변경한다.

```

####배열의 프로퍼티 열거
for in 으로 모든 프로퍼티를 열거 하기 때문에 동적프로퍼티도 출력된다.  
배열의 요소만 출력하고 싶으면 기존 for문을 사용하는 것이 좋다.

####배열 요소 삭제
요소, 프로퍼티를 삭제하는데 delete 연산자를 사용할 수 있다.

```
var arr = ['zero','one','two'];
delete arr[1]; // ['zero',undefined,'two']
arr.length // 3

arr.splice(1,1); // ['zero','two']
arr.length // 2
```
해당 요소의 참조값을 삭제할 뿐이지 원소 자체를 삭제하지 않는다.

배열을 조작하고 싶을 경우 **splice()**배열 메서드를 사용한다.
splice (start,deleteCount, item)
* start 배열에서 시작위치
* deleteCount - start에서 지정한 시작 위치부터 삭제할 요소의 수
* item 삭제할 위치에 추가할 요소


####Array() 생성자 함수
배열도 리터럴로 생성하지만. 배열 리터럴도 결국 JS기본 제공 Array() 생성자 함수를 단순화 한 것.

**Array() 생성자 함수는 호출할 때 인자 개수에 따라 동작이 다르다**
1. 호출할 때 인자가 1개이고, 숫자일 경우 : 호출된 인자를 length로 갖는 빈 배열 생성
2. 이외 호출된 인자를 요소로 갖는 배열 생성.


```
var arr = new Array(3); // [undefined, undefined, undefined]
var arr = new Array(1,2,3); // [1,2,3]
```

####유사 배열 객체
배열의 length 프로퍼티는 배열 동작의 중요한 프로퍼티. 일반 객체에 length 프로퍼티가 있으면 유사 배열 객체를 사용 할 수 있다.
객체임에도 표준 배열 메서드를 사용하는 게 가능
```
var arr = ['bar'];
var obj ={
    name : 'hojun',
    1ength : 1 
    };
    
arr.push('hosun'); ['bar','hosun']
obj.push('hosun') // not working    
```

obj는 유사 배열 객체 인경우 apply() 메서드를 사용하면 객체지만 표준 배열 메서드를 활용할 수 있다.

####기본 타입과 표준 메서드
JS는 숫자, 문자, 불린, 각 타입별로 호출 가능한 표준 메서드 정의 메서드 처리 순간 객체로 변환 타입별 표준 메서드 호출
** 표준 메서드들은 객체처럼 호출할 수 있다**

####연산자

#####+ 연산자
더하기 연산, 문자열 연결 연산에 사용

#####typeof 연산자
피연산자 타입을 문자열 형태로 리턴 null과 배열은 Object이고 함수는 function으로 나온다.

#####==(동등) 연산자와 === (일치) 연산자.
JS에서는 두 값이 동일한지 확인한다. 두 연산자 모두 사용할 수 있다.  
* == : 비교하려는 피연산자의 타입이 다를 경우 타입 변환을 거친 다음 비교
* === : 피연산자의 타입이 다를 경우에 타입을 변경하지 않고 비교.

```
1 == '1' // true 피연산자 타입을 변환하여 두 값이 같다 판단
1 === '1' // false 피연산자 타입이 다르므로 바로 false
```

**==연산자는 타입 변환 등 다른 값을 얻을 수 있다. ===연산자를 권장한다.**

##### !! 연산자.
!! 비연산자를 불린값으로 변환.
```
consloe.log(!!0);           // false
consloe.log(!!1);           // true
consloe.log(!!'');          // false
consloe.log(!!null);        // false
consloe.log(!!undefined);   // false
consloe.log(!!{});          // true
```
객체는 값이 비어있어도 true로 변환되는 것을 주의.

