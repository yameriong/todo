# JPA

객체 모델링의 장점을 이용하지 않고 테이블 구조에 객체를 맞춰 데이터 통신하는 Mapper만 만들어서 사용하고 있는 것 이로 인하여
많은 crud를 다시 만들면서 개발에 많은 시간이 들지만

ORM(Object Relational Mapping) 중 표준 중 하나인 JPA로 객체 모델링 관계형 데이터베이스 사이의 차이도 해결 가능함.
1. CRUD의 sql을 작성 할 필요가 없다.
2. 조회결과를 객체 매핑하는 작업도 처리 가능하다.
3. 네이티브 sql 사용으로 직접 작성이 가능하다.
4. DB의 변경시 별도 sql 처리 없이 개발 가능.

JPA를 사용하면서 객체 중심으로 개발하여 생산성, 유지보수가 좋아졌고 테스트 작성하기도 편리해졌습니다.

개발 중 객체의 구조가 변경시 

```{.java}
@Entity(name = "Member")
@Data
class Member{    
    @Id         // 주키 설정
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 자동 숫자 증가
    private Long id;
    private String name;
}

- > 
@Entity(name = "Member")
@Data
class Member{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private Team team;
}

@Entity(name = "Team")
@Data
class Team{        
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String teamName;
}
```
각 sql 질의문이 쓰여지는 모든곳에 수정하여야 합니다.

데이터 접근 계층을 사용해서 sql을 숨겨도 DAO를 열어서 어떤 sql이 실행되는지 확인해야 하는 점.

비지니스 요구사항을 모델링한 객체를 엔티티라고 하는데 db종속적인 상황에서 엔티티를 신뢰할 수 없다.

DAO에 쿼리문을 열어 어떤 Join으로 나온 결과인지 확인해야 하는데 ***물리적으로는 SQL과 JDBC API데이터 접근 계층에
숨기는 것에 성공했을지 몰라도 논리적으로는 엔티티와 아주 강한 의존관계이다.***

이런 의존관계는 객체에 필드 추가 할 때도 퍼시스턴트레이어를 모두 변경해야 합니다.

SQL에 종속적인 개발자에서 탈피해보자!.

Hibernate 예제





